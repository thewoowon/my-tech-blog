---
title: Project Self-Diagnosis List
description: 프로젝트 자가 진단 리스트로 프로젝트를 돌아보고, 개선할 점을 찾아보자.
thumbnail: /assets/feeling.png
prerequisites: ['우원', 'FE Developer','FE Developer','안녕하세요. 우원입니다.']
stacks: ['REACT']
writer: 우원
date: '2023-01-19'
name: '20230119_1' 
lock: 'false'
---

# 프로젝트 자가 진단 리스트

[ ] 실제 서비스를 공개적으로 배포, 운영<br></br>
[ ] 유저의 피드백에 따라 성능/사용성을 개선하고 신규 기능을 추가<br></br>
[ ] 발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리<br></br>
[ ] 코드를 지속적으로 리펙토링하고 디자인패턴을 적용<br></br>
[ ] 위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민<br></br>
[ ] 반복되는 수정과 배포에 수반되는 작업들을 자동화<br></br>
[ ] 언어나 프레임워크의 기능만으로 구현 할 수 없는 것들을 직접 구현<br></br>
[ ] 내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선<br></br>
[ ] 코드나 제품의 퀄리티를 유지하기 위한 분석툴이나 테스트툴을 도입<br></br>
[ ] 타인과의 협업을 효율적으로 하기위한 고민

# 나의 프로젝트 리스트

1. 고객 대응 챗봇 (2022.01 ~ 2022.04)
2. 고객 대응 챗봇 매니저 (2022.04 ~ 2022.05)
3. 유비케어 기술블로그 (2022.07 ~ 2022.08)
4. 샐러드피스(2022.09 ~ 2022.11)
5. 하이!애자일(2022.10 ~ 2022.12)
6. 러브콩 스테인드 글라스(2022.11 ~ 2022.12)

# 프로젝트별 자가 진단 해보기

### 1. 고객 대응 챗봇 리뷰 및 평가

고객 대응 챗봇의 경우는 내가 첫번째 회사에서 근무할 때 진행했던 개인 프로젝트이다.
Microsoft Bot Framework를 사용하여 챗봇을 만들었고, IIS를 활용해 배포하였다.

해결하려고 했던 문제는 고객들이 개발자들의 비상주 시간에는 문의를 할 수 없다는 것이었다.
9시부터 18시까지, 근무 시간에만 고객들이 문의를 할 수 있었고, 그 외 시간에는 고객들이 문의를 할 수 없었다.
만약에 솔루션을 늦은 시간이나 외국에 나가서 사용을 한다고 가정해 보자.
만약 오류가 발생하거나 간단한 문의를 하고 싶은데, 개발자들이 비상주 시간에는 문의를 할 수 없다면 어떻게 해야할까?
물론 다음날까지 기다리는 수 밖에 없다.
하지만 챗봇이 있다면 해당 문제를 해결할 수 있다.
비상주 시간에도 고객들이 문의를 할 수 있고, 개발자들은 비상주 시간에도 챗봇을 통해 문의를 받을 수 있다.
또한 자주 질문하는 내용에 대해서 챗봇이 즉시 답을 해주기 때문에 사용자 경험에서도 만족도가 높은 서비스라고 판단했다.

[ ] 실제 서비스를 공개적으로 배포, 운영<br></br>
-> 실제로 IIS로 외부에 공개적으로 배포하고 1개 고객사에 시범운영을 했다.<br></br>
[ ] 유저의 피드백에 따라 성능/사용성을 개선하고 신규 기능을 추가<br></br>
-> 챗봇을 정기회의에서 시연하고 챗봇의 활용방안과 개선점을 피드백 받았다.<br></br>
-> 고정 메뉴를 추가하고 Vertical 리스트로 메뉴를 출력하는 기능을 추가했다.<br></br>
[ ] 발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리<br></br>
-> 개선 사항을 종합하고 팀원들과 공유했다.<br></br>
[ ❌ ] 코드를 지속적으로 리펙토링하고 디자인패턴을 적용<br></br>
[ ❌ ] 위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민<br></br>
[ ❌ ] 반복되는 수정과 배포에 수반되는 작업들을 자동화<br></br>
[ ] 언어나 프레임워크의 기능만으로 구현 할 수 없는 것들을 직접 구현<br></br>
-> Azure Bot Service를 활용하면 SaaS로 챗봇을 쉽게 구현할 수 있지만, 챗봇의 기능을 확장하기 위해서는 직접 구현해야 했다.<br></br>
[ ❌ ] 내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선<br></br>
[ ❌ ] 코드나 제품의 퀄리티를 유지하기 위한 분석툴이나 테스트툴을 도입<br></br>
[ ❌ ] 타인과의 협업을 효율적으로 하기위한 고민

### 2. 고객 대응 챗봇 매니저 리뷰 및 평가

고객 대응 챗봇 매니저는 고객 대응 챗봇을 관리하기 위한 프로젝트이다.
고객사마다 품질 관리 정책이 다르기 때문에 챗봇을 일일이 개발자가 직접 커스텀해서 관리해야 했다.
이를 해결하기 위해 챗봇을 관리할 수 있는 웹앱을 개발했다.
블레이저를 활용해서 챗봇을 관리할 수 있도록 개발했다.
메뉴의 구성을 카테고리, 중간 메뉴, 디테일로 구성했다.
솔루션에 고객사를 유일하게 구분하는 코드가 빌트인 된 링크를 제공했다.
해당 링크를 클릭하면 자동으로 쿼리스트링에 코드가 들어가고, 해당 코드를 통해 고객사를 구분했다.
로그인 후 메뉴를 선택하면 해당 메뉴에 맞는 챗봇을 관리할 수 있도록 구성했다.

[ ] 실제 서비스를 공개적으로 배포, 운영<br></br>
-> IIS를 활용해 사내망에 배포, 고객사에 공개<br></br>
[ ] 유저의 피드백에 따라 성능/사용성을 개선하고 신규 기능을 추가<br></br>
-> 이미지 업로드 기능 추가, 토스트 메시지 추가<br></br>
[ ] 발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리<br></br>
-> 이미지 업로드 기능의 버그를 수정, 카테고리 트리 버그 수정<br></br>
[ ] 코드를 지속적으로 리펙토링하고 디자인패턴을 적용<br></br>
-> 싱글톤 패턴 적용<br></br>
[ ❌ ] 위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민<br></br>
[ ❌ ] 반복되는 수정과 배포에 수반되는 작업들을 자동화<br></br>
[ ] 언어나 프레임워크의 기능만으로 구현 할 수 없는 것들을 직접 구현<br></br>
-> 카테고리 트리 구현<br></br>
[ ❌ ] 내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선<br></br>
[ ❌ ] 코드나 제품의 퀄리티를 유지하기 위한 분석툴이나 테스트툴을 도입<br></br>
[ ❌ ] 타인과의 협업을 효율적으로 하기위한 고민

### 3. 유비케어 기술블로그 리뷰 및 평가

유비케어 기술 블로그의 경우는 유비케어 재직 당시 기술 블로그 운영이 중단된 상태를 확인하고,
Jekyll로 구현한 기존 기술 블로그를 NEXT.js로 마이그레이션 및 리뉴얼을 제안, 이후 개발을 진행했다.

[ ] 실제 서비스를 공개적으로 배포, 운영<br></br>
-> Vercel 배포<br></br>
[ ] 유저의 피드백에 따라 성능/사용성을 개선하고 신규 기능을 추가<br></br>
-> 태그, 최근글 기능 추가, fixed position, 댓글 기능 추가<br></br>
[ ❌ ] 발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리<br></br>
[ ❌ ] 코드를 지속적으로 리펙토링하고 디자인패턴을 적용<br></br>
[ ❌ ] 위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민<br></br>
[ ] 반복되는 수정과 배포에 수반되는 작업들을 자동화<br></br>
-> Vercel을 Github과 연동하여 자동 배포<br></br>
[ ❌ ] 언어나 프레임워크의 기능만으로 구현 할 수 없는 것들을 직접 구현<br></br>
[ ❌ ] 내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선<br></br>
[ ❌ ] 코드나 제품의 퀄리티를 유지하기 위한 분석툴이나 테스트툴을 도입<br></br>
[ ] 타인과의 협업을 효율적으로 하기위한 고민<br></br>
-> Github을 통한 협업, 슬랙을 활용한 커뮤니케이션

### 4. 샐러드피스 리뷰 및 평가

[ ] 실제 서비스를 공개적으로 배포, 운영<br></br>
-> Vercel 배포, Heroku 배포<br></br>
[ ] 유저의 피드백에 따라 성능/사용성을 개선하고 신규 기능을 추가<br></br>
-> 실시간 주문자 모니터링 기능 구현<br></br>
[ ❌ ] 발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리<br></br>
[ ❌ ] 코드를 지속적으로 리펙토링하고 디자인패턴을 적용<br></br>
[ ❌ ] 위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민<br></br>
[ ] 반복되는 수정과 배포에 수반되는 작업들을 자동화<br></br>
-> Vercel을 Github과 연동하여 자동 배포, Heroku Cli를 통한 자동 배포<br></br>
[ ❌ ] 언어나 프레임워크의 기능만으로 구현 할 수 없는 것들을 직접 구현<br></br>
[ ] 내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선<br></br>
-> 커스텀 데코레이터 작성<br></br>
[ ] 코드나 제품의 퀄리티를 유지하기 위한 분석툴이나 테스트툴을 도입<br></br>
-> Jest를 통한 테스트 코드 작성, Cypress를 통한 E2E 테스트 코드 작성<br></br>
[ ] 타인과의 협업을 효율적으로 하기위한 고민<br></br>
-> Github을 통한 협업

### 5. 하이!애자일 리뷰 및 평가

[ ] 실제 서비스를 공개적으로 배포, 운영<br></br>
-> Vercel 배포, Heroku 배포<br></br>
[ ] 유저의 피드백에 따라 성능/사용성을 개선하고 신규 기능을 추가<br></br>
-> 스프린트 캘린더 기능<br></br>
[ ] 발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리<br></br>
-> 노션을 통한 이슈 관리<br></br>
[ ] 코드를 지속적으로 리펙토링하고 디자인패턴을 적용<br></br>
-> 컴포넌트 분리, 리팩토링 진행<br></br>
[ ] 위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민<br></br>
-> 더 좋은 설계를 위해 노력하였으며, 일정 지연 발생<br></br>
[ ] 반복되는 수정과 배포에 수반되는 작업들을 자동화<br></br>
-> Vercel을 Github과 연동하여 자동 배포, Heroku Cli를 통한 자동 배포<br></br>
[ ] 언어나 프레임워크의 기능만으로 구현 할 수 없는 것들을 직접 구현<br></br>
-> 커스텀 데코레이터 작성<br></br>
[ ❌ ] 내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선<br></br>
[ ❌ ] 코드나 제품의 퀄리티를 유지하기 위한 분석툴이나 테스트툴을 도입<br></br>
[ ] 타인과의 협업을 효율적으로 하기위한 고민<br></br>
-> Github을 통한 협업, Notion을 통한 일정관리

### 6. 러브콩 스테인드 글라스 리뷰 및 평가

[ ] 실제 서비스를 공개적으로 배포, 운영<br></br>
-> https://www.lovekong-glass.com/<br></br>
[ ] 유저의 피드백에 따라 성능/사용성을 개선하고 신규 기능을 추가<br></br>
-> QNA 기능 추가, 인스타그램 모달 기능 추가<br></br>
[ ❌ ] 발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리<br></br>
[ ] 코드를 지속적으로 리펙토링하고 디자인패턴을 적용<br></br>
-> 꾸준한 리팩토링 진행<br></br>
[ ] 위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민<br></br>
-> 빠른 개발 진행 후 리팩토링 진행<br></br>
[ ] 반복되는 수정과 배포에 수반되는 작업들을 자동화<br></br>
-> Vercel을 Github과 연동하여 자동 배포<br></br>
[ ] 언어나 프레임워크의 기능만으로 구현 할 수 없는 것들을 직접 구현<br></br>
-> 커스텀 훅 작성<br></br>
[ ❌ ] 내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선<br></br>
[ ] 코드나 제품의 퀄리티를 유지하기 위한 분석툴이나 테스트툴을 도입<br></br>
-> Google Analytics를 통한 유저 행동 분석<br></br>
[ ] 타인과의 협업을 효율적으로 하기위한 고민<br></br>
-> Github을 통한 협업


